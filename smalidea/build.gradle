/*
 * Copyright 2013, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath 'gradle.plugin.org.jetbrains:gradle-intellij-plugin:0.0.40'
        classpath 'org.eclipse.jgit:org.eclipse.jgit:2.0.0.201206130900-r'
    }
}

apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'antlr'

version = '0.03'

if (!('release' in gradle.startParameter.taskNames)) {
    def versionSuffix
    try {
        def git = org.eclipse.jgit.api.Git.open(file('..'))
        def head = git.getRepository().getRef('HEAD')
        versionSuffix = head.getObjectId().abbreviate(8).name()

        if (!git.status().call().clean) {
            versionSuffix += '-dirty'
        }
    } catch (Exception ex) {
        // In case we can't get the commit for some reason,
        // just use -dev
        versionSuffix = 'dev'
    }

    def baseVersion = version
    version = baseVersion + '-' + versionSuffix
} else {
    if (System.env.JDK7_HOME == null && !JavaVersion.current().isJava7()) {
        throw new InvalidUserDataException("bzzzzzzzt. Release builds must be performed with java 7. " +
                "Either run gradle with java 7, or define the JDK7_HOME environment variable.")
    }
}

if (System.env.JDK7_HOME != null) {
    sourceCompatibility = 1.7
    targetCompatibility = 1.7

    tasks.withType(JavaCompile) {
        doFirst {
            options.fork = true
            options.bootClasspath = "$System.env.JDK7_HOME/jre/lib/rt.jar"
            options.bootClasspath += "$File.pathSeparator$System.env.JDK7_HOME/jre/lib/jsse.jar"
        }
    }
}

// We don't want to use the org.jetbrains.intellij plugin when generating the idea project files,
// so that idea classes aren't included as project dependencies, since they will already exist
// in the plugin sdk defined for the project
if (!('idea' in gradle.startParameter.taskNames)) {
    apply plugin: 'org.jetbrains.intellij'

    intellij {
        version 'IC-14.1.4'
        pluginName 'smalidea'

        sandboxDirectory "${buildDir}/sandbox"
    }

    // This prints out the directories that can be used to configure a plugin sdk in IDEA, using
    // the copy of IDEA downloaded by the org.jetbrains.intellij plugin
    task ideaDirs() {
        project.afterEvaluate {
            if (intellij != null) {
                println "IDEA Plugin jdk: ${intellij.ideaDirectory}"
                println "sources: ${project.configurations['intellij-sources'].files[0]}"
            }
        }
    }

    dependencies {
        compile files("${System.properties['java.home']}/../lib/tools.jar")
    }
} else {
    // If we're running the idea task, let's make sure nothing else is being run, since
    // we have to use a special configuration for the idea task
    if (gradle.startParameter.taskNames.size() > 1) {
        throw new InvalidUserDataException("The idea task must be run by itself.")
    }
}

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
    compile 'org.smali:smali:2.1.2-205bf333'
    compile 'org.antlr:antlr-runtime:3.5.2'
    compile 'com.google.code.gson:gson:2.3.1'

    antlr 'org.antlr:antlr:3.5.2'
}

idea {
    project {
        jdkName = 'IDEA Plugin jdk'
        languageLevel 1.7

        vcs = 'Git'

        ipr {
            withXml {
                def node = it.asNode()

                node.find { it.@name == 'ProjectRootManager' }
                    .@'project-jdk-type' = 'IDEA JDK'

                node.find { it.@name == 'VcsDirectoryMappings' }
                    .mapping.@directory = '$PROJECT_DIR$/..'

                def componentNode = node.find { it.@name == 'ProjectRunConfigurationManager' }

                if (componentNode == null) {
                    componentNode = it.node.appendNode 'component', [name: 'ProjectRunConfigurationManager']
                }

                if (componentNode.find { it.@name == 'All tests' } == null) {
                    componentNode.append(new XmlParser().parseText("""
                        <configuration default="false" name="All tests" type="JUnit" factoryName="JUnit">
                          <extension name="coverage" enabled="false" merge="false" runner="idea" />
                          <module name="smalidea" />
                          <option name="TEST_OBJECT" value="directory" />
                          <option name="VM_PARAMETERS" value="-Didea.system.path=${buildDir}/sandbox/config -Didea.system.path=${buildDir}/sandbox/system-test -Didea.load.plugins.id=org.jf.smalidea" />
                          <option name="WORKING_DIRECTORY" value="file://\$PROJECT_DIR\$" />
                          <option name="PASS_PARENT_ENVS" value="true" />
                          <option name="TEST_SEARCH_SCOPE">
                            <value defaultName="moduleWithDependencies" />
                          </option>
                          <dir value="\$PROJECT_DIR\$/src/test/java" />
                        </configuration>"""))
                }
            }
        }
    }

    module {
        excludeDirs -= buildDir
        if (buildDir.exists()) {
            excludeDirs.addAll(buildDir.listFiles())
        }

        for (sourceDir in (sourceDirs + testSourceDirs)) {
            excludeDirs.remove(sourceDir);
            while ((sourceDir = sourceDir.getParentFile()) != null) {
                excludeDirs.remove(sourceDir);
            }
        }

        iml {
            withXml {
                def node = it.node

                node.@type = 'PLUGIN_MODULE'

                def pluginUrl = 'file://$MODULE_DIR$/src/main/resources/META-INF/plugin.xml'

                def pluginNode = node.find { it.@name == 'DevKit.ModuleBuildProperties' }
                if (pluginNode == null) {
                    node.appendNode 'component', [name: 'DevKit.ModuleBuildProperties',
                                                  url: pluginUrl]
                } else {
                    pluginNode.@url = pluginUrl
                }
            }
        }
    }
}

task extractTokens(type: org.gradle.api.tasks.Copy) {
    def allArtifacts = configurations.default.resolvedConfiguration.resolvedArtifacts
    def smaliArtifact = allArtifacts.find { it.moduleVersion.id.name.equals('smali') }

    from(zipTree(smaliArtifact.file)) {
        include '**/*.tokens'
    }
    into "${buildDir}/tokens"
}

generateGrammarSource {
    def tokensDir = file("${buildDir}/tokens/org/jf/smali")
    inputs.file new File(tokensDir, 'smaliParser.tokens')
    setArguments(['-lib', tokensDir.path])
    outputDirectory(file("${buildDir}/generated-src/antlr/main/org/jf/smalidea"))
}
generateGrammarSource.dependsOn(extractTokens)

ideaModule.dependsOn(generateGrammarSource)

task release(dependsOn: ':buildPlugin') {
}