group baksmali;

smaliFile(classDef) ::=
<<
.class <classDef.AccessFlags; separator=" "> <classDef.ClassType>
.super <classDef.SuperType>
<if(classDef.Interfaces)>

# interfaces
<classDef.Interfaces: implement(it); separator="\n">

<endif>
<if(classDef.StaticFields)>


# static fields
<classDef.StaticFields: field(it); separator="\n">

<endif>
<if(classDef.InstanceFields)>


# instance fields
<classDef.InstanceFields: field(it); separator="\n">

<endif>
<if(classDef.DirectMethods)>


# direct methods
<classDef.DirectMethods: method(it); separator="\n\n">

<endif>
<if(classDef.VirtualMethods)>


# virtual methods
<classDef.VirtualMethods: method(it); separator="\n\n">

<endif>
>>



                 
implement(interface) ::=
<<
.implements <interface>
>>




field(fieldDef) ::=
<<
.field <fieldDef.AccessFlags; separator=" "> <fieldDef.FieldName>:<fieldDef.FieldType><if(fieldDef.InitialValue)> = <fieldDef.InitialValue: EncodedValue(it)><endif>
>>


method(methodDef) ::=
<<
.method <methodDef.AccessFlags; separator=" "> <methodDef.MethodName><methodDef.Prototype>
    <if(methodDef.hasCode)>
    .registers <methodDef.RegisterCount>

    <methodDef.MethodItems: MethodItem(it); separator="\n"> 
    <endif>
.end method
>>

MethodItem(MethodItem) ::=
<<
<MethodItem: (MethodItem.Template)(MethodItem)>
>>



Format31tLabelMap ::= [
    "fill-array-data":"array_",
    "packed-switch":"pswitch_data_",
    "sparse-switch":"sswitch_data_"
]


Register(num) ::=
<<
v<num; format="decimal">
>>



Format10t(Instruction) ::=
<<
<Instruction.Opcode> goto_<Instruction.Target>:
>>

Format10x(Instruction) ::=
<<
<Instruction.Opcode>
>>

Format11n(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.Register)>, <Instruction.Literal>
>>

Format11x(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.Register)>
>>

Format12x(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.RegisterA)>, <Register(Instruction.RegisterB)>
>>

Format20t(Instruction) ::=
<<
<Instruction.Opcode> goto_<Instruction.Target>:
>>

Format21c(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.Register)>, <Reference(Instruction.Reference)>
>>

Format21h(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.Register)>, <Instruction.Literal>
>>

Format21s(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.Register)>, <Instruction.Literal>
>>

Format21t(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.Register)>, cond_<Instruction.Target>:
>>

Format22b(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.RegisterA)>, <Register(Instruction.RegisterB)>, <Instruction.Literal>
>>

Format22c(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.RegisterA)>, <Register(Instruction.RegisterB)>, <Reference(Instruction.Reference)>
>>

Format22s(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.RegisterA)>, <Register(Instruction.RegisterB)>, <Instruction.Literal>
>>

Format22t(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.RegisterA)>, <Register(Instruction.RegisterB)>, cond_<Instruction.Target>
>>

Format22x(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.RegisterA)>, <Register(Instruction.RegisterB)>
>>

Format23x(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.RegisterA)>, <Register(Instruction.RegisterB)>, <Register(Instruction.RegisterC)>
>>

Format30t(Instruction) ::=
<<
<Instruction.Opcode> goto_<Instruction.Target>:
>>

Format31c(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.Register)>, <Reference(Instruction.Reference)>
>>

Format31i(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.Register)>, <Instruction.Literal>
>>

Format31t(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.Register)>, <Format31tLabelMap.(Instruction.Opcode)><Instruction.Target>:
>>

Format32x(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.RegisterA)>, <Register(Instruction.RegisterB)>
>>

Format35c(Instruction) ::=
<<
<Instruction.Opcode> {<Instruction.Registers: Register(it); separator=", ">}, <Reference(Instruction.Reference)>
>>

Format3rc(Instruction) ::=
<<
<Instruction.Opcode> {<Register(Instruction.StartRegister)> .. <Register(Instruction.LastRegister)>}, <Reference(Instruction.Reference)>
>>

Format51l(Instruction) ::=
<<
<Instruction.Opcode> <Register(Instruction.Register)>, <Instruction.Literal>
>>

ArrayData(Instruction) ::=
<<
.array-data <Instruction.ElementWidth>
    <Instruction.Values: {<it.ByteArray; format="unsigned",separator=" ">}; separator="\n">
.end array-data
>>

PackedSwitchData(Instruction) ::=
<<
.packed-switch <Instruction.FirstKey>
        <Instruction.Targets: {pswitch_<it>:}; separator="\n">
.end packed-switch
>>


Label(Label) ::=
<<
<Label.Prefix><Label.HexOffset>:
>>

Blank(Blank) ::=
<<

>>


Reference(ReferencedItem) ::=
<<
<(ReferencedItem.Template)(ReferencedItem)>
>>

StringReference(StringReference) ::=
<<
"<StringReference.EscapedValue>"
>>

FieldReference(FieldReference) ::=
<<
<FieldReference.ContainingClass>-><FieldReference.FieldName>:<FieldReference.FieldType>
>>

MethodReference(MethodReference) ::=
<<
<MethodReference.ContainingClass>-><MethodReference.MethodName><MethodReference.Prototype>
>>



EncodedValue(EncodedValue) ::=
<<
<(EncodedValue.Format)(EncodedValue)>
>>

SimpleEncodedValue(EncodedValue) ::=
<<
<EncodedValue.Value>
>>

StringEncodedValue(EncodedValue) ::=
<<
"<EncodedValue.Value>"
>>