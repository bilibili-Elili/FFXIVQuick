group baksmali;

smaliFile(AccessFlags, ClassType, SuperType, SourceFile, Interfaces, Annotations, StaticFields,
          InstanceFields, DirectMethods, VirtualMethods) ::=
<<
.class <AccessFlags: {<it> }><ClassType>
<if(SuperType)>
.super <SuperType>
<endif>
<if(SourceFile)>

.source "<SourceFile>"


<endif>
<if(Interfaces)>

# interfaces
<Interfaces: implement(it); separator="\n">

<endif>
<if(Annotations)>


# annotations
<Annotations; separator="\n\n">

<endif>
<if(StaticFields)>


# static fields
<StaticFields; separator="\n">

<endif>
<if(InstanceFields)>


# instance fields
<InstanceFields; separator="\n">

<endif>
<if(DirectMethods)>


# direct methods
<DirectMethods; separator="\n\n">

<endif>
<if(VirtualMethods)>


# virtual methods
<VirtualMethods; separator="\n\n">

<endif>
>>



                 
implement(interface) ::=
<<
.implements <interface>
>>


annotation(Visibility, AnnotationType, Elements) ::=
<<
.annotation <Visibility> <AnnotationType>
<if(Elements)>
    <Elements; separator="\n">
<endif>
<if(Elements)>


<endif>
.end annotation
>>



field(AccessFlags, FieldName, FieldType, Annotations, InitialValue) ::=
<<
.field <AccessFlags: {<it> }><FieldName>:<FieldType><if(InitialValue)> = <InitialValue><endif>
<if(Annotations)>
    <Annotations; separator="\n\n">
.end field

<endif>
>>


method(AccessFlags, MethodName, Prototype, HasCode, RegisterCount, Parameters, Annotations, MethodItems) ::=
<<
.method <AccessFlags: {<it> }><MethodName><Prototype>
<if(HasCode)>
    .registers <RegisterCount>
  <if(Parameters)>
    <Parameters; separator="\n">
  <endif>
  <if(Annotations)>
    <Annotations; separator="\n\n">
  <endif>

    <MethodItems; separator="\n">
<elseif(Annotations)>
    <Annotations; separator="\n\n">
<endif>
.end method
>>

Parameter(ParameterName, Annotations) ::=
<<
.parameter<if(ParameterName)> "<ParameterName>"<endif><if(Annotations)>

    <Annotations; separator="\n\n">
.end parameter
<endif>
>>



Format31tLabelMap ::= [
    "fill-array-data":"array_",
    "packed-switch":"pswitch_data_",
    "sparse-switch":"sswitch_data_"
]


Format10t(Opcode, Target) ::=
<<
<Opcode> goto_<Target>:
>>

Format10x(Opcode) ::=
<<
<Opcode>
>>

Format11n(Opcode, Register, Literal) ::=
<<
<Opcode> <Register>, <Literal>
>>

Format11x(Opcode, Register) ::=
<<
<Opcode> <Register>
>>

Format12x(Opcode, RegisterA, RegisterB) ::=
<<
<Opcode> <RegisterA>, <RegisterB>
>>

Format20t(Opcode, Target) ::=
<<
<Opcode> goto_<Target>:
>>

Format21c(Opcode, Register, Reference) ::=
<<
<Opcode> <Register>, <Reference>
>>

Format21h(Opcode, Register, Literal) ::=
<<
<Opcode> <Register>, <Literal>
>>

Format21s(Opcode, Register, Literal) ::=
<<
<Opcode> <Register>, <Literal>
>>

Format21t(Opcode, Register, Target) ::=
<<
<Opcode> <Register>, cond_<Target>:
>>

Format22b(Opcode, RegisterA, RegisterB, Literal) ::=
<<
<Opcode> <RegisterA>, <RegisterB>, <Literal>
>>

Format22c(Opcode, RegisterA, RegisterB, Reference) ::=
<<
<Opcode> <RegisterA>, <RegisterB>, <Reference>
>>

Format22cs(Opcode, RegisterA, RegisterB, FieldOffset) ::=
<<
<Opcode> <RegisterA>, <RegisterB>, Field@<FieldOffset>
>>

Format22csf(Opcode, RegisterA, RegisterB, Reference) ::=
<<
<Opcode> <RegisterA>, <RegisterB>, <Reference>
>>

Format22csn(Register) ::=
<<
#Couldn't determine field access while deodexing, replaced with generic method call
invoke-virtual <Register>, Ljava/lang/Object;->hashCode()I
>>

Format22s(Opcode, RegisterA, RegisterB, Literal) ::=
<<
<Opcode> <RegisterA>, <RegisterB>, <Literal>
>>

Format22t(Opcode, RegisterA, RegisterB, Target) ::=
<<
<Opcode> <RegisterA>, <RegisterB>, cond_<Target>:
>>

Format22x(Opcode, RegisterA, RegisterB) ::=
<<
<Opcode> <RegisterA>, <RegisterB>
>>

Format23x(Opcode, RegisterA, RegisterB, RegisterC) ::=
<<
<Opcode> <RegisterA>, <RegisterB>, <RegisterC>
>>

Format30t(Opcode, Target) ::=
<<
<Opcode> goto_<Target>:
>>

Format31c(Opcode, Register, Reference) ::=
<<
<Opcode> <Register>, <Reference>
>>

Format31i(Opcode, Register, Literal) ::=
<<
<Opcode> <Register>, <Literal>
>>

Format31t(Opcode, Register, Target) ::=
<<
<Opcode> <Register>, <Format31tLabelMap.(Opcode)><Target>:
>>

Format32x(Opcode, RegisterA, RegisterB) ::=
<<
<Opcode> <RegisterA>, <RegisterB>
>>

Format35c(Opcode, Registers, Reference) ::=
<<
<Opcode> {<Registers; separator=", ">}, <Reference>
>>

Format35s(Opcode, Registers, Reference) ::=
<<
<Opcode> {<Registers; separator=", ">}, <Reference>
>>

Format35sf(Opcode, Registers, Reference) ::=
<<
<Opcode> {<Registers; separator=", ">}, <Reference>
>>

Format35ms(Opcode, Registers, MethodIndex) ::=
<<
<Opcode> {<Registers; separator=", ">}, vtable@<MethodIndex>
>>

Format35msf(Opcode, Registers, Reference) ::=
<<
<Opcode> {<Registers; separator=", ">}, <Reference>
>>

Format35msn(Register) ::=
<<
#Couldn't determine method while deodexing, replaced with generic method call
invoke-virtual <Register>, Ljava/lang/Object;->hashCode()I
>>

Format3rc(Opcode, StartRegister, LastRegister, Reference) ::=
<<
<Opcode> {<StartRegister> .. <LastRegister>}, <Reference>
>>

Format3rms(Opcode, StartRegister, LastRegister, MethodIndex) ::=
<<
<Opcode> {<StartRegister> .. <LastRegister>}, vtable@<MethodIndex>
>>

Format3rmsf(Opcode, StartRegister, LastRegister, Reference) ::=
<<
<Opcode> {<StartRegister> .. <LastRegister>}, <Reference>
>>

Format51l(Opcode, Register, Literal) ::=
<<
<Opcode> <Register>, <Literal>
>>

ArrayData(Opcode, ElementWidth, Values) ::=
<<
.array-data <ElementWidth>
    <Values; separator="\n">
.end array-data
>>

ArrayElement(Bytes) ::=
<<
<Bytes; format="unsigned",separator=" ">
>>

PackedSwitchData(Opcode, FirstKey, Targets) ::=
<<
.packed-switch <FirstKey>
    <Targets: {pswitch_<it>:}; separator="\n">
.end packed-switch
>>

SparseSwitchData(Opcode, Targets) ::=
<<
.sparse-switch
    <Targets:{<it.Value> -> sswitch_<it.Target>:}; separator="\n">
.end sparse-switch
>>


Label(Prefix, HexOffset) ::=
<<
<Prefix><HexOffset>:
>>

Line(Line) ::=
<<
.line <Line; format="decimal">
>>

EndPrologue(Prologue) ::=
<<
.prologue
>>

StartEpilogue(Epilogue) ::=
<<
.epilogue
>>

StartLocal(Register, Name, Type, Signature) ::=
<<
.local <Register>, <Name>:<Type><if(Signature)>,"<Signature>"<endif>
>>

EndLocal(Register, Name, Type, Signature) ::=
<<
.end local <Register>       <if(Name)>#<Name>:<Type>,<if(Signature)>, "<Signature>"<endif><endif>
>>

RestartLocal(Register, Name, Type, Signature) ::=
<<
.restart local <Register>       <if(Name)>#<Name>:<Type>,<if(Signature)>, "<Signature>"<endif><endif>
>>

SetFile(FileName) ::=
<<
.source "<FileName>" 
>>

Blank(Blank) ::=
<<

>>

Catch(ExceptionType, StartAddress, EndAddress, HandlerAddress) ::=
<<
.catch <ExceptionType> {try_start_<StartAddress>: .. try_end_<EndAddress>:} handler_<HandlerAddress>:
>>

CatchAll(StartAddress, EndAddress, HandlerAddress) ::=
<<
.catchall {try_start_<StartAddress>: .. try_end_<EndAddress>:} handler_<HandlerAddress>: 
>>



StringReference(EscapedValue) ::=
<<
"<EscapedValue>"
>>

FieldReference(ContainingClass, FieldName, FieldType) ::=
<<
<ContainingClass>-><FieldName>:<FieldType>
>>

MethodReference(ContainingClass, MethodName, Prototype) ::=
<<
<ContainingClass>-><MethodName><Prototype>
>>

TypeReference(TypeDescriptor) ::=
<<
<TypeDescriptor>
>>



SimpleEncodedValue(Value) ::=
<<
<Value>
>>

EncodedIndexedItemReference(Value) ::=
<<
<Value>
>>

ArrayEncodedValue(Value) ::=
<<
{
    <Value; separator=",\n">
}
>>

EnumEncodedValue(Value) ::=
<<
.enum <Value>
>>

AnnotationEncodedValue(AnnotationType, Elements) ::=
<<
.subannotation <AnnotationType>
    <Elements; separator="\n">
.end subannotation
>>

AnnotationElement(Name, Value) ::=
<<
<Name> = <Value>
>>